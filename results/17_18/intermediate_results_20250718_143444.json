[
  {
    "quid": 2000014,
    "question": "Who would wish to visit Ireland in July, the year of 2007?",
    "ground_truth": [
      "Bertie Ahern"
    ],
    "analysis": {
      "question_type": "entity_query",
      "time_constraints": "July 2007",
      "key_entities": [
        "Ireland"
      ],
      "target_relations": [
        "Make_a_visit",
        "Host_a_visit"
      ],
      "answer_type": "entity",
      "query_strategy": "首先，识别问题中的时间约束为2007年7月。然后，查找在2007年7月期间与'Ireland'相关的实体，这些实体通过'Make_a_visit'或'Host_a_visit'关系与'Ireland'相连。最终返回这些实体作为答案。"
    },
    "generated_code": "def query_kg(df):\n    try:\n        results = []\n        # 实体名称标准化函数\n        def normalize_entity(entity):\n            return str(entity).replace(' ', '_').replace('-', '_')\n        # 模糊匹配函数\n        def fuzzy_match(target, candidates):\n            target_norm = normalize_entity(target.lower())\n            matches = []\n            for candidate in candidates:\n                if target_norm in normalize_entity(candidate.lower()) or normalize_entity(candidate.lower()) in target_norm:\n                    matches.append(candidate)\n            return matches\n        # 根据分析结果生成具体查询逻辑\n        target_entity = 'Ireland'\n        target_relations = ['Make_a_visit', 'Host_a_visit']\n        time_start = '2007-07-01'\n        time_end = '2007-07-31'\n        # 模糊匹配目标实体\n        all_entities = set(df['head']).union(set(df['tail']))\n        matched_entities = fuzzy_match(target_entity, all_entities)\n        if not matched_entities:\n            return []\n        # 查询符合条件的记录\n        for entity in matched_entities:\n            # 作为tail的情况 (Make_a_visit)\n            mask1 = (df['tail'].str.lower() == entity.lower()) & \\\n                    (df['relation'].isin(target_relations)) & \\\n                    (df['timestamp'] >= time_start) & \\\n                    (df['timestamp'] <= time_end)\n            # 作为head的情况 (Host_a_visit)\n            mask2 = (df['head'].str.lower() == entity.lower()) & \\\n                    (df['relation'].isin(target_relations)) & \\\n                    (df['timestamp'] >= time_start) & \\\n                    (df['timestamp'] <= time_end)\n            # 合并结果\n            relevant_records = df[mask1 | mask2]\n            # 收集相关实体\n            for _, row in relevant_records.iterrows():\n                if row['relation'] == 'Make_a_visit':\n                    results.append(row['head'])\n                elif row['relation'] == 'Host_a_visit':\n                    results.append(row['tail'])\n        # 去重并返回\n        return list(set(results))\n    except Exception as e:\n        print(f\"查询错误: {e}\")\n        return []",
    "predicted_answers": [
      "Bertie_Ahern"
    ],
    "evaluation": {
      "exact_match": true,
      "precision": 1.0,
      "recall": 1.0,
      "f1": 1.0,
      "predicted_count": 1,
      "ground_truth_count": 1,
      "intersection_count": 1
    }
  },
  {
    "quid": 2000015,
    "question": "In which year did Viktor Orban visit Iran for the first time?",
    "ground_truth": [
      "2015"
    ],
    "analysis": {
      "question_type": "first_event",
      "time_constraints": "时间范围为2005-01-01到2015-12-31，需要查找在此时间范围内最早发生的事件",
      "key_entities": [
        "Viktor_Orban",
        "Iran"
      ],
      "target_relations": [
        "Make_a_visit"
      ],
      "answer_type": "time",
      "query_strategy": "首先在知识图谱中查找所有Viktor_Orban与Iran之间关系为'Make_a_visit'的事件，然后在这些事件中筛选出时间最早的事件，返回该事件发生的年份。由于问题询问的是'first time'，因此需要特别注意时间顺序，确保找到的是最早的一次访问。"
    },
    "generated_code": "def query_kg(df):\n    try:\n        results = []\n        # 实体名称标准化函数\n        def normalize_entity(entity):\n            return str(entity).replace(' ', '_').replace('-', '_')\n        # 模糊匹配函数\n        def fuzzy_match(target, candidates):\n            target_norm = normalize_entity(target.lower())\n            matches = []\n            for candidate in candidates:\n                if target_norm in normalize_entity(candidate.lower()) or normalize_entity(candidate.lower()) in target_norm:\n                    matches.append(candidate)\n            return matches\n        # 根据分析结果生成具体查询逻辑\n        # 获取所有可能的实体匹配\n        head_matches = fuzzy_match('Viktor Orban', df['head'].unique())\n        tail_matches = fuzzy_match('Iran', df['tail'].unique())\n        # 筛选符合条件的记录\n        filtered = df[\n            (df['head'].isin(head_matches)) &\n            (df['tail'].isin(tail_matches)) &\n            (df['relation'] == 'Make_a_visit') &\n            (df['timestamp'] >= '2005-01-01') &\n            (df['timestamp'] <= '2015-12-31')\n        ]\n        if not filtered.empty:\n            # 按时间排序并获取最早的事件\n            earliest = filtered.sort_values('timestamp').iloc[0]\n            # 提取年份\n            year = earliest['timestamp'].split('-')[0]\n            results.append(year)\n        return results\n    except Exception as e:\n        print(f\"查询错误: {e}\")\n        return []",
    "predicted_answers": [],
    "evaluation": {
      "exact_match": false,
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "predicted_count": 0,
      "ground_truth_count": 1,
      "intersection_count": 0
    }
  },
  {
    "quid": 2000016,
    "question": "Who made optimistic remarks about Iran after the Organisation for Economic Cooperation and Development?",
    "ground_truth": [
      "South Korea",
      "Party Member (Iraq)",
      "France",
      "China",
      "Iraq",
      "Member of Legislative (Govt) (Iran)",
      "Japan",
      "Head of Government (Ukraine)",
      "Thailand",
      "Kazakhstan"
    ],
    "analysis": {
      "question_type": "entity_query",
      "time_constraints": "after the Organisation for Economic Cooperation and Development (OECD) event, within the time range of 2005-01-01 to 2015-12-31",
      "key_entities": [
        "Organisation_for_Economic_Cooperation_and_Development",
        "Iran"
      ],
      "target_relations": [
        "Make_statement",
        "Praise_or_endorse",
        "Make_optimistic_comment"
      ],
      "answer_type": "entity",
      "query_strategy": "1. First, identify the time when the Organisation for Economic Cooperation and Development (OECD) made any statement or had any interaction involving Iran. 2. Then, search for events after that specific time where someone made optimistic remarks about Iran, using the relations 'Make_statement', 'Praise_or_endorse', or 'Make_optimistic_comment'. 3. Return the entity (person or organization) that made the optimistic remarks."
    },
    "generated_code": "def query_kg(df):\n    try:\n        results = []\n        # 实体名称标准化函数\n        def normalize_entity(entity):\n            return str(entity).replace(' ', '_').replace('-', '_')\n        # 模糊匹配函数\n        def fuzzy_match(target, candidates):\n            target_norm = normalize_entity(target.lower())\n            matches = []\n            for candidate in candidates:\n                if target_norm in normalize_entity(candidate.lower()) or normalize_entity(candidate.lower()) in target_norm:\n                    matches.append(candidate)\n            return matches\n        # 1. 首先找到OECD涉及伊朗的事件的最早时间\n        oecd_entities = fuzzy_match('Organisation_for_Economic_Cooperation_and_Development', df['head'].unique().tolist() + df['tail'].unique().tolist())\n        iran_entities = fuzzy_match('Iran', df['head'].unique().tolist() + df['tail'].unique().tolist())\n        oecd_iran_events = df[\n            ((df['head'].isin(oecd_entities) & df['tail'].isin(iran_entities)) |\n            ((df['tail'].isin(oecd_entities) & df['head'].isin(iran_entities))\n        ]\n        if oecd_iran_events.empty:\n            return []\n        # 获取OECD与伊朗互动的最早时间\n        oecd_time = oecd_iran_events['timestamp'].min()\n        # 2. 在OECD事件之后，查找对伊朗做出乐观评论的实体\n        target_relations = ['Make_statement', 'Praise_or_endorse', 'Make_optimistic_comment']\n        optimistic_comments = df[\n            (df['relation'].isin(target_relations)) &\n            (df['tail'].isin(iran_entities)) &\n            (df['timestamp'] > oecd_time) &\n            (df['timestamp'] >= '2005-01-01') &\n            (df['timestamp'] <= '2015-12-31')\n        ]\n        # 3. 提取做出评论的实体\n        if not optimistic_comments.empty:\n            results = optimistic_comments['head'].unique().tolist()\n        return results\n    except Exception as e:\n        print(f\"查询错误: {e}\")\n        return []))",
    "predicted_answers": [],
    "evaluation": {
      "exact_match": false,
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "predicted_count": 0,
      "ground_truth_count": 10,
      "intersection_count": 0
    }
  },
  {
    "quid": 2000017,
    "question": "Who made optimistic remarks about Yasuo Fukuda after Japan?",
    "ground_truth": [
      "Government Official (Japan)",
      "China"
    ],
    "analysis": {
      "question_type": "entity_query",
      "time_constraints": "after Japan (需要先确定Japan与Yasuo_Fukuda相关事件的时间点，然后查找之后的时间段)",
      "key_entities": [
        "Japan",
        "Yasuo_Fukuda"
      ],
      "target_relations": [
        "Praise_or_endorse",
        "Make_statement",
        "Make_optimistic_comment"
      ],
      "answer_type": "entity",
      "query_strategy": "1. 首先确定Japan与Yasuo_Fukuda相关的最后一个事件的时间点。2. 在该时间点之后的时间范围内，查找包含Yasuo_Fukuda作为tail实体，且关系为Praise_or_endorse或Make_statement的事件。3. 返回这些事件的head实体作为答案。"
    },
    "generated_code": "def query_kg(df):\n    try:\n        results = []\n        # 实体名称标准化函数\n        def normalize_entity(entity):\n            return str(entity).replace(' ', '_').replace('-', '_')\n        # 模糊匹配函数\n        def fuzzy_match(target, candidates):\n            target_norm = normalize_entity(target.lower())\n            matches = []\n            for candidate in candidates:\n                if target_norm in normalize_entity(candidate.lower()) or normalize_entity(candidate.lower()) in target_norm:\n                    matches.append(candidate)\n            return matches\n        # 根据分析结果生成具体查询逻辑\n        # 1. 首先确定Japan与Yasuo_Fukuda相关的最后一个事件的时间点\n        japan_matches = fuzzy_match('Japan', df['head'].unique().tolist() + df['tail'].unique().tolist())\n        yasuo_matches = fuzzy_match('Yasuo Fukuda', df['head'].unique().tolist() + df['tail'].unique().tolist())\n        if not japan_matches or not yasuo_matches:\n            return []\n        # 查找Japan和Yasuo_Fukuda共同出现的事件\n        japan_yasuo_events = df[\n            ((df['head'].isin(japan_matches) & df['tail'].isin(yasuo_matches)) |\n             (df['head'].isin(yasuo_matches) & df['tail'].isin(japan_matches)))\n        ]\n        if japan_yasuo_events.empty:\n            return []\n        # 获取最后一个事件的时间戳\n        last_event_time = japan_yasuo_events['timestamp'].max()\n        # 2. 在该时间点之后的时间范围内，查找包含Yasuo_Fukuda作为tail实体，且关系为Praise_or_endorse或Make_statement的事件\n        target_relations = ['Praise_or_endorse', 'Make_statement', 'Make_optimistic_comment']\n        yasuo_as_tail = df[\n            (df['tail'].isin(yasuo_matches)) &\n            (df['relation'].isin(target_relations)) &\n            (df['timestamp'] > last_event_time)\n        ]\n        # 3. 返回这些事件的head实体作为答案\n        results = list(yasuo_as_tail['head'].unique())\n        return results\n    except Exception as e:\n        print(f\"查询错误: {e}\")\n        return []",
    "predicted_answers": [],
    "evaluation": {
      "exact_match": false,
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "predicted_count": 0,
      "ground_truth_count": 2,
      "intersection_count": 0
    }
  },
  {
    "quid": 2000018,
    "question": "In which month did Xi Jinping praise the Bahamas?",
    "ground_truth": [
      "2015-01"
    ],
    "analysis": {
      "question_type": "time_query",
      "time_constraints": "时间范围为2005-01-01到2015-12-31，问题未指定具体年份，需在全部时间范围内搜索",
      "key_entities": [
        "Xi_Jinping",
        "Bahamas"
      ],
      "target_relations": [
        "Praise_or_endorse"
      ],
      "answer_type": "time",
      "query_strategy": "1. 首先在知识图谱中查找所有包含'Xi_Jinping'作为head实体和'Bahamas'作为tail实体的三元组；2. 筛选这些三元组中关系为'Praise_or_endorse'的实例；3. 从符合条件的三元组中提取时间信息，确定具体的月份；4. 如果没有明确的时间信息，则可能需要进一步分析相关事件的时间上下文"
    },
    "generated_code": "def query_kg(df):\n    try:\n        results = []\n        # 实体名称标准化函数\n        def normalize_entity(entity):\n            return str(entity).replace(' ', '_').replace('-', '_')\n        # 模糊匹配函数\n        def fuzzy_match(target, candidates):\n            target_norm = normalize_entity(target.lower())\n            matches = []\n            for candidate in candidates:\n                if target_norm in normalize_entity(candidate.lower()) or normalize_entity(candidate.lower()) in target_norm:\n                    matches.append(candidate)\n            return matches\n        # 根据分析结果生成具体查询逻辑\n        # 1. 模糊匹配查找相关实体\n        xi_jinping_matches = fuzzy_match('Xi_Jinping', df['head'].unique())\n        bahamas_matches = fuzzy_match('Bahamas', df['tail'].unique())\n        # 2. 筛选符合条件的三元组\n        filtered = df[\n            (df['head'].isin(xi_jinping_matches)) &\n            (df['tail'].isin(bahamas_matches)) &\n            (df['relation'] == 'Praise_or_endorse') &\n            (df['timestamp'] >= '2005-01-01') &\n            (df['timestamp'] <= '2015-12-31')\n        ]\n        # 3. 提取时间信息并确定月份\n        if not filtered.empty:\n            # 按时间排序\n            filtered = filtered.sort_values('timestamp')\n            # 提取月份信息\n            months = filtered['timestamp'].str[:7].unique().tolist()\n            results = months\n        return results\n    except Exception as e:\n        print(f\"查询错误: {e}\")\n        return []",
    "predicted_answers": [],
    "evaluation": {
      "exact_match": false,
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "predicted_count": 0,
      "ground_truth_count": 1,
      "intersection_count": 0
    }
  }
]