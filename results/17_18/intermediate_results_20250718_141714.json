[
  {
    "quid": 2000014,
    "question": "Who would wish to visit Ireland in July, the year of 2007?",
    "ground_truth": [
      "Bertie Ahern"
    ],
    "analysis": {
      "question_type": "entity_query",
      "time_constraints": "July 2007",
      "key_entities": [
        "Ireland"
      ],
      "target_relations": [
        "Make_a_visit",
        "Host_a_visit"
      ],
      "answer_type": "entity",
      "query_strategy": "首先在知识图谱中查找与'Ireland'相关的实体，然后筛选出在2007年7月发生的事件。重点关注'Make_a_visit'和'Host_a_visit'这两种关系，以确定谁在2007年7月访问了爱尔兰或谁在爱尔兰接待了访问者。"
    },
    "generated_code": "def query_kg(df):\n    try:\n        results = []\n        # 过滤数据\n        filtered_df = df[\n            (df['head'].str.contains('Ireland', case=False, na=False) | \n            (df['tail'].str.contains('Ireland', case=False, na=False)) &\n            ((df['relation'] == 'Make_a_visit') | (df['relation'] == 'Host_a_visit'))\n        ]\n        # 处理时间约束\n        for _, row in filtered_df.iterrows():\n            if 'year' in row and 'month' in row:\n                date_str = f\"{row['year']}-{row['month']:02d}\"\n                if date_str == \"2007-07\":\n                    if not pd.isna(row['head']) and 'Ireland' not in str(row['head']):\n                        results.append(str(row['head']))\n                    if not pd.isna(row['tail']) and 'Ireland' not in str(row['tail']):\n                        results.append(str(row['tail']))\n            elif 'timestamp' in row:\n                date_str = row['timestamp'].strftime('%Y-%m')\n                if date_str == \"2007-07\":\n                    if not pd.isna(row['head']) and 'Ireland' not in str(row['head']):\n                        results.append(str(row['head']))\n                    if not pd.isna(row['tail']) and 'Ireland' not in str(row['tail']):\n                        results.append(str(row['tail']))\n            elif 'date_str' in row:\n                if row['date_str'].startswith(\"2007-07\"):\n                    if not pd.isna(row['head']) and 'Ireland' not in str(row['head']):\n                        results.append(str(row['head']))\n                    if not pd.isna(row['tail']) and 'Ireland' not in str(row['tail']):\n                        results.append(str(row['tail']))\n        return list(set(results))  # 去重\n    except Exception as e:\n        return [])",
    "predicted_answers": [],
    "evaluation": {
      "exact_match": false,
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "predicted_count": 0,
      "ground_truth_count": 1,
      "intersection_count": 0
    }
  },
  {
    "quid": 2000015,
    "question": "In which year did Viktor Orban visit Iran for the first time?",
    "ground_truth": [
      "2015"
    ],
    "analysis": {
      "question_type": "first_event",
      "time_constraints": "时间范围为2005-01-01到2015-12-31，可用年份为2005至2015",
      "key_entities": [
        "Viktor_Orban",
        "Iran"
      ],
      "target_relations": [
        "Make_a_visit"
      ],
      "answer_type": "time",
      "query_strategy": "首先在知识图谱中查找所有Viktor_Orban与Iran之间关系为'Make_a_visit'的事件，然后在这些事件中筛选出时间最早的事件，返回该事件发生的年份。由于问题询问的是'first time'，因此需要确保找到的是时间上最早的一次访问。"
    },
    "generated_code": "def query_kg(df):\n    try:\n        results = []\n        # 过滤数据\n        filtered_df = df[\n            (df['head'] == 'Viktor_Orban') & \n            (df['relation'] == 'Make_a_visit') & \n            (df['tail'] == 'Iran')\n        ]\n        # 如果没有找到记录，返回空列表\n        if filtered_df.empty:\n            return []\n        # 确保有时间列\n        if 'timestamp' not in filtered_df.columns:\n            return []\n        # 按时间排序并获取最早记录\n        filtered_df = filtered_df.sort_values('timestamp')\n        first_visit = filtered_df.iloc[0]\n        # 获取年份\n        visit_year = first_visit['timestamp'].year\n        if 2005 <= visit_year <= 2015:\n            results.append(str(visit_year))\n        return results\n    except Exception as e:\n        return []",
    "predicted_answers": [],
    "evaluation": {
      "exact_match": false,
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "predicted_count": 0,
      "ground_truth_count": 1,
      "intersection_count": 0
    }
  },
  {
    "quid": 2000016,
    "question": "Who made optimistic remarks about Iran after the Organisation for Economic Cooperation and Development?",
    "ground_truth": [
      "South Korea",
      "Party Member (Iraq)",
      "France",
      "China",
      "Iraq",
      "Member of Legislative (Govt) (Iran)",
      "Japan",
      "Head of Government (Ukraine)",
      "Thailand",
      "Kazakhstan"
    ],
    "analysis": {
      "question_type": "entity_query",
      "time_constraints": "after the Organisation for Economic Cooperation and Development (OECD) event, within the time range of 2005-01-01 to 2015-12-31",
      "key_entities": [
        "Organisation_for_Economic_Cooperation_and_Development",
        "Iran"
      ],
      "target_relations": [
        "Make_statement",
        "Praise_or_endorse",
        "Make_optimistic_comment"
      ],
      "answer_type": "entity",
      "query_strategy": "1. First, identify the time when the Organisation for Economic Cooperation and Development (OECD) made a statement or took an action involving Iran. 2. Then, search for events after that time where an entity made optimistic remarks about Iran, using the relations 'Make_statement', 'Praise_or_endorse', or 'Make_optimistic_comment'. 3. Return the entity (head) that made the optimistic remarks."
    },
    "generated_code": "def query_kg(df):\n    try:\n        results = []\n        # Step 1: Find OECD events involving Iran\n        oecd_events = df[\n            (df['head'] == 'Organisation_for_Economic_Cooperation_and_Development') & \n            (df['tail'] == 'Iran') & \n            (df['year'] >= 2005) & \n            (df['year'] <= 2015)\n        ]\n        if oecd_events.empty:\n            return []\n        # Get the latest OECD event date\n        latest_oecd_date = oecd_events['timestamp'].max()\n        # Step 2: Find optimistic remarks about Iran after OECD event\n        optimistic_remarks = df[\n            (df['tail'] == 'Iran') & \n            (df['relation'].isin(['Make_statement', 'Praise_or_endorse', 'Make_optimistic_comment'])) & \n            (df['timestamp'] > latest_oecd_date)\n        ]\n        # Process results\n        for _, row in optimistic_remarks.iterrows():\n            if not pd.isna(row['head']):\n                results.append(str(row['head']))\n        return list(set(results))\n    except Exception as e:\n        return []",
    "predicted_answers": [],
    "evaluation": {
      "exact_match": false,
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "predicted_count": 0,
      "ground_truth_count": 10,
      "intersection_count": 0
    }
  },
  {
    "quid": 2000017,
    "question": "Who made optimistic remarks about Yasuo Fukuda after Japan?",
    "ground_truth": [
      "Government Official (Japan)",
      "China"
    ],
    "analysis": {
      "question_type": "entity_query",
      "time_constraints": "after Japan (需要先确定Japan与Yasuo_Fukuda相关事件的时间点，然后查找该时间点之后的事件)",
      "key_entities": [
        "Japan",
        "Yasuo_Fukuda"
      ],
      "target_relations": [
        "Praise_or_endorse",
        "Make_statement",
        "Make_optimistic_comment"
      ],
      "answer_type": "entity",
      "query_strategy": "1. 首先在知识图谱中查找Japan与Yasuo_Fukuda相关的所有事件，确定这些事件的时间点；2. 然后在这些时间点之后的时间范围内，查找包含Praise_or_endorse、Make_statement或Make_optimistic_comment关系的事件；3. 最后提取这些事件中的主体(entity)作为答案"
    },
    "generated_code": "def query_kg(df):\n    try:\n        results = []\n        # 第一步：查找Japan与Yasuo_Fukuda相关的事件\n        japan_fukuda_events = df[\n            ((df['head'] == 'Japan') & (df['tail'] == 'Yasuo_Fukuda')) |\n            ((df['head'] == 'Yasuo_Fukuda') & (df['tail'] == 'Japan'))\n        ]\n        if japan_fukuda_events.empty:\n            return []\n        # 获取相关事件的时间点\n        event_dates = []\n        for _, row in japan_fukuda_events.iterrows():\n            if 'date_str' in df.columns and not pd.isna(row['date_str']):\n                event_dates.append(row['date_str'])\n            elif 'timestamp' in df.columns and not pd.isna(row['timestamp']):\n                event_dates.append(row['timestamp'].strftime('%Y-%m-%d'))\n            elif 'year' in df.columns and not pd.isna(row['year']):\n                month = row['month'] if 'month' in df.columns and not pd.isna(row['month']) else 1\n                event_dates.append(f\"{row['year']}-{month:02d}-01\")\n        if not event_dates:\n            return []\n        # 第二步：查找在这些时间点之后的乐观评论\n        for date in event_dates:\n            optimistic_comments = df[\n                (df['head'] == 'Yasuo_Fukuda') &\n                (df['relation'].isin(['Praise_or_endorse', 'Make_statement', 'Make_optimistic_comment'])) &\n                (\n                    (df['date_str'] > date) if 'date_str' in df.columns else \n                    (df['timestamp'] > date) if 'timestamp' in df.columns else\n                    (f\"{df['year']}-{df['month']:02d}-01\" > date) if 'year' in df.columns and 'month' in df.columns else False\n                )\n            ]\n            for _, row in optimistic_comments.iterrows():\n                if not pd.isna(row['tail']):\n                    results.append(str(row['tail']))\n        return list(set(results))\n    except Exception as e:\n        return []",
    "predicted_answers": [],
    "evaluation": {
      "exact_match": false,
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "predicted_count": 0,
      "ground_truth_count": 2,
      "intersection_count": 0
    }
  },
  {
    "quid": 2000018,
    "question": "In which month did Xi Jinping praise the Bahamas?",
    "ground_truth": [
      "2015-01"
    ],
    "analysis": {
      "question_type": "time_query",
      "time_constraints": "时间范围为2005-01-01到2015-12-31，问题未指定具体年份，需在全部时间范围内搜索",
      "key_entities": [
        "Xi_Jinping",
        "Bahamas"
      ],
      "target_relations": [
        "Praise_or_endorse"
      ],
      "answer_type": "time",
      "query_strategy": "1. 首先在知识图谱中查找所有涉及'Xi_Jinping'作为head实体、'Bahamas'作为tail实体、关系为'Praise_or_endorse'的三元组。2. 从匹配的三元组中提取时间信息。3. 如果没有精确到月份的时间信息，可能需要进一步查询相关事件的具体时间。4. 最终返回事件发生的具体月份。"
    },
    "generated_code": "def query_kg(df):\n    try:\n        results = []\n        # 过滤数据\n        filtered_df = df[\n            (df['head'] == 'Xi_Jinping') & \n            (df['relation'] == 'Praise_or_endorse') &\n            (df['tail'] == 'Bahamas') &\n            (df['timestamp'] >= '2005-01-01') &\n            (df['timestamp'] <= '2015-12-31')\n        ]\n        # 处理结果\n        for _, row in filtered_df.iterrows():\n            if not pd.isna(row['timestamp']):\n                month_str = row['timestamp'].strftime('%Y-%m')\n                results.append(month_str)\n        return list(set(results))  # 去重\n    except Exception as e:\n        return []",
    "predicted_answers": [],
    "evaluation": {
      "exact_match": false,
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "predicted_count": 0,
      "ground_truth_count": 1,
      "intersection_count": 0
    }
  }
]