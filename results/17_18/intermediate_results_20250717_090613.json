[
  {
    "quid": 2000014,
    "question": "Who would wish to visit Ireland in July, the year of 2007?",
    "ground_truth": [
      "Bertie Ahern"
    ],
    "analysis": {
      "question_type": "entity_query",
      "time_constraints": {
        "year": "2007",
        "month": "July",
        "time_range": "2005-01-01 to 2015-12-31"
      },
      "key_entities": [
        "Ireland"
      ],
      "target_relations": [
        "Make_a_visit",
        "Host_a_visit"
      ],
      "answer_type": "entity",
      "query_strategy": "The question is asking about who would wish to visit Ireland in July 2007. The key entity is 'Ireland', and the relevant relations are 'Make_a_visit' (indicating someone visiting Ireland) and 'Host_a_visit' (indicating Ireland hosting a visit). The time constraint is July 2007. The strategy is to query the knowledge graph for entities (heads) that have a 'Make_a_visit' relation with 'Ireland' (tail) during July 2007. Alternatively, we can look for 'Host_a_visit' relations where 'Ireland' is the head and another entity is the tail during the same time period."
    },
    "generated_code": "def query_kg(df):\n    import pandas as pd\n    from datetime import datetime\n    try:\n        # 基础时间过滤\n        df = df[(df['timestamp'] >= '2005-01-01') & (df['timestamp'] <= '2015-12-31')]\n        # 时间约束处理\n        time_constraints = \"{'year': '2007', 'month': 'July', 'time_range': '2005-01-01 to 2015-12-31'}\"\n        if time_constraints:\n            if '2007-07' in time_constraints:\n                df = df[(df['year'] == 2007) & (df['month'] == 7)]\n            elif 'after' in time_constraints.lower():\n                pass\n            elif any(year in time_constraints for year in ['2005', '2006', '2007', '2008', '2009', '2010', '2011', '2012', '2013', '2014', '2015']):\n                for year in ['2005', '2006', '2007', '2008', '2009', '2010', '2011', '2012', '2013', '2014', '2015']:\n                    if year in time_constraints:\n                        df = df[df['year'] == int(year)]\n                        break\n        # 实体过滤\n        key_entities = ['Ireland']\n        if key_entities:\n            entity_filter = pd.Series([False] * len(df))\n            for entity in key_entities:\n                entity_filter |= (\n                    df['head'].str.contains(entity, case=False, na=False) |\n                    df['tail'].str.contains(entity, case=False, na=False) |\n                    (df['head'] == entity) |\n                    (df['tail'] == entity)\n                )\n            df = df[entity_filter]\n        # 关系过滤\n        target_relations = ['Make_a_visit', 'Host_a_visit']\n        if target_relations:\n            relation_filter = pd.Series([False] * len(df))\n            for rel in target_relations:\n                relation_filter |= (\n                    (df['relation'] == rel) |\n                    df['relation'].str.contains(rel, case=False, na=False)\n                )\n            df = df[relation_filter]\n        if df.empty:\n            return []\n        # 返回相关实体\n        results = []\n        for _, row in df.iterrows():\n            if any(entity in str(row['head']).lower() for entity in [e.lower() for e in key_entities]):\n                results.append(row['tail'])\n            elif any(entity in str(row['tail']).lower() for entity in [e.lower() for e in key_entities]):\n                results.append(row['head'])\n        # 去重\n        results = list(set(results))\n        return results\n    except Exception as e:\n        print(f\"查询执行错误: {{e}}\")\n        return []",
    "predicted_answers": [],
    "evaluation": {
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "exact_match": false
    }
  },
  {
    "quid": 2000015,
    "question": "In which year did Viktor Orban visit Iran for the first time?",
    "ground_truth": [
      "2015"
    ],
    "analysis": {
      "question_type": "first_event",
      "time_constraints": "时间范围为2005-01-01到2015-12-31，可用年份为2005至2015",
      "key_entities": [
        "Viktor_Orban",
        "Iran"
      ],
      "target_relations": [
        "Make_a_visit",
        "Host_a_visit"
      ],
      "answer_type": "time",
      "query_strategy": "首先在知识图谱中查找Viktor_Orban与Iran之间所有涉及'Make_a_visit'或'Host_a_visit'关系的事件，然后在这些事件中筛选出时间最早的事件，返回该事件发生的年份。由于问题询问的是'first time'，因此需要特别注意时间顺序，确保找到的是最早的一次访问。"
    },
    "generated_code": "def query_kg(df):\n    import pandas as pd\n    from datetime import datetime\n    try:\n        # 基础时间过滤\n        df = df[(df['timestamp'] >= '2005-01-01') & (df['timestamp'] <= '2015-12-31')]\n        # 实体过滤\n        key_entities = ['Viktor_Orban', 'Iran']\n        if len(key_entities) >= 2:\n            entity1, entity2 = key_entities[0], key_entities[1]\n            # 双向匹配：entity1->entity2 或 entity2->entity1\n            df_filtered = df[\n                ((df['head'].str.contains(entity1, case=False, na=False) | \n                  df['head'] == entity1) & \n                 (df['tail'].str.contains(entity2, case=False, na=False) | \n                  df['tail'] == entity2)) |\n                ((df['head'].str.contains(entity2, case=False, na=False) | \n                  df['head'] == entity2) & \n                 (df['tail'].str.contains(entity1, case=False, na=False) | \n                  df['tail'] == entity1)\n            ]\n        else:\n            return []\n        # 关系过滤\n        target_relations = ['Make_a_visit', 'Host_a_visit']\n        if target_relations:\n            relation_filter = df_filtered['relation'].isin(target_relations)\n            for rel in target_relations:\n                relation_filter |= df_filtered['relation'].str.contains(rel, case=False, na=False)\n            df_filtered = df_filtered[relation_filter]\n        if df_filtered.empty:\n            return []\n        # 找到最早的事件\n        earliest_event = df_filtered.loc[df_filtered['timestamp'].idxmin()]\n        # 根据答案类型返回结果\n        answer_type = \"time\"\n        if answer_type == 'time':\n            return [str(earliest_event['year'])]\n        else:\n            return [earliest_event['head'], earliest_event['tail']]\n    except Exception as e:\n        print(f\"查询执行错误: {{e}}\")\n        return [])",
    "predicted_answers": [],
    "evaluation": {
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "exact_match": false
    }
  },
  {
    "quid": 2000016,
    "question": "Who made optimistic remarks about Iran after the Organisation for Economic Cooperation and Development?",
    "ground_truth": [
      "South Korea",
      "Party Member (Iraq)",
      "France",
      "China",
      "Iraq",
      "Member of Legislative (Govt) (Iran)",
      "Japan",
      "Head of Government (Ukraine)",
      "Thailand",
      "Kazakhstan"
    ],
    "analysis": {
      "question_type": "entity_query",
      "time_constraints": "after the Organisation for Economic Cooperation and Development (OECD) event, within the time range of 2005-01-01 to 2015-12-31",
      "key_entities": [
        "Iran",
        "Organisation_for_Economic_Cooperation_and_Development"
      ],
      "target_relations": [
        "Make_statement",
        "Praise_or_endorse",
        "Make_optimistic_comment"
      ],
      "answer_type": "entity",
      "query_strategy": "1. First, identify the time when the Organisation for Economic Cooperation and Development (OECD) made a statement or had an event involving Iran. 2. Then, search for events after that time where someone made optimistic remarks about Iran, using the relations 'Make_statement', 'Praise_or_endorse', or 'Make_optimistic_comment'. 3. Return the entity (person or organization) that made the optimistic remarks."
    },
    "generated_code": "def query_kg(df):\n    import pandas as pd\n    from datetime import datetime\n    try:\n        # 基础时间过滤\n        df = df[(df['timestamp'] >= '2005-01-01') & (df['timestamp'] <= '2015-12-31')]\n        # 时间约束处理\n        time_constraints = \"after the Organisation for Economic Cooperation and Development (OECD) event, within the time range of 2005-01-01 to 2015-12-31\"\n        if time_constraints:\n            if 'after' in time_constraints.lower():\n                # 找到OECD事件的时间\n                oecd_events = df[\n                    (df['head'].str.contains('Organisation_for_Economic_Cooperation_and_Development', case=False, na=False) |\n                     df['tail'].str.contains('Organisation_for_Economic_Cooperation_and_Development', case=False, na=False)) &\n                    (df['relation'].isin(['Make_statement', 'Hold_event', 'Participate_in']))\n                ]\n                if not oecd_events.empty:\n                    latest_oecd_event = oecd_events['timestamp'].max()\n                    df = df[df['timestamp'] > latest_oecd_event]\n        # 实体过滤\n        key_entities = ['Iran', 'Organisation_for_Economic_Cooperation_and_Development']\n        if key_entities:\n            entity_filter = pd.Series([False] * len(df))\n            for entity in key_entities:\n                entity_filter |= (\n                    df['head'].str.contains(entity, case=False, na=False) |\n                    df['tail'].str.contains(entity, case=False, na=False) |\n                    (df['head'] == entity) |\n                    (df['tail'] == entity)\n                )\n            df = df[entity_filter]\n        # 关系过滤\n        target_relations = ['Make_statement', 'Praise_or_endorse', 'Make_optimistic_comment']\n        if target_relations:\n            relation_filter = pd.Series([False] * len(df))\n            for rel in target_relations:\n                relation_filter |= (\n                    (df['relation'] == rel) |\n                    df['relation'].str.contains(rel, case=False, na=False)\n                )\n            df = df[relation_filter]\n        if df.empty:\n            return []\n        # 返回相关实体\n        results = []\n        for _, row in df.iterrows():\n            if any(entity.lower() in str(row['head']).lower() for entity in key_entities):\n                if str(row['tail']) not in key_entities:\n                    results.append(row['tail'])\n            elif any(entity.lower() in str(row['tail']).lower() for entity in key_entities):\n                if str(row['head']) not in key_entities:\n                    results.append(row['head'])\n        # 去重\n        results = list(set(results))\n        return results\n    except Exception as e:\n        print(f\"查询执行错误: {{e}}\")\n        return []",
    "predicted_answers": [],
    "evaluation": {
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "exact_match": false
    }
  },
  {
    "quid": 2000017,
    "question": "Who made optimistic remarks about Yasuo Fukuda after Japan?",
    "ground_truth": [
      "Government Official (Japan)",
      "China"
    ],
    "analysis": {
      "question_type": "entity_query",
      "time_constraints": "after Japan (需要先确定Japan与Yasuo_Fukuda相关事件的时间点，然后查找该时间点之后的事件)",
      "key_entities": [
        "Japan",
        "Yasuo_Fukuda"
      ],
      "target_relations": [
        "Praise_or_endorse",
        "Make_statement",
        "Make_optimistic_comment"
      ],
      "answer_type": "entity",
      "query_strategy": "1. 首先在知识图谱中查找Japan与Yasuo_Fukuda之间的所有相关事件，确定这些事件的时间点；2. 然后在这些时间点之后的时间范围内，查找包含Praise_or_endorse、Make_statement或Make_optimistic_comment关系的事件；3. 最后返回这些事件中的主体(entity)作为答案"
    },
    "generated_code": "def query_kg(df):\n    import pandas as pd\n    from datetime import datetime\n    try:\n        # 基础时间过滤\n        df = df[(df['timestamp'] >= '2005-01-01') & (df['timestamp'] <= '2015-12-31')]\n        # 时间约束处理\n        time_constraints = \"after Japan (需要先确定Japan与Yasuo_Fukuda相关事件的时间点，然后查找该时间点之后的事件)\"\n        if time_constraints:\n            # 首先找到Japan与Yasuo_Fukuda相关事件的时间点\n            japan_fukuda_events = df[\n                ((df['head'] == 'Japan') & (df['tail'] == 'Yasuo_Fukuda')) |\n                ((df['tail'] == 'Japan') & (df['head'] == 'Yasuo_Fukuda'))\n            ]\n            if not japan_fukuda_events.empty:\n                latest_event_time = japan_fukuda_events['timestamp'].max()\n                df = df[df['timestamp'] > latest_event_time]\n        # 实体过滤\n        key_entities = ['Japan', 'Yasuo_Fukuda']\n        if key_entities:\n            entity_filter = pd.Series([False] * len(df))\n            for entity in key_entities:\n                entity_filter |= (\n                    df['head'].str.contains(entity, case=False, na=False) |\n                    df['tail'].str.contains(entity, case=False, na=False) |\n                    (df['head'] == entity) |\n                    (df['tail'] == entity)\n                )\n            df = df[entity_filter]\n        # 关系过滤\n        target_relations = ['Praise_or_endorse', 'Make_statement', 'Make_optimistic_comment']\n        if target_relations:\n            relation_filter = pd.Series([False] * len(df))\n            for rel in target_relations:\n                relation_filter |= (\n                    (df['relation'] == rel) |\n                    df['relation'].str.contains(rel, case=False, na=False)\n                )\n            df = df[relation_filter]\n        if df.empty:\n            return []\n        # 返回相关实体\n        results = []\n        for _, row in df.iterrows():\n            if any(entity in str(row['head']).lower() for entity in [e.lower() for e in key_entities]):\n                results.append(row['tail'])\n            elif any(entity in str(row['tail']).lower() for entity in [e.lower() for e in key_entities]):\n                results.append(row['head'])\n        # 去重\n        results = list(set(results))\n        return results\n    except Exception as e:\n        print(f\"查询执行错误: {{e}}\")\n        return []",
    "predicted_answers": [],
    "evaluation": {
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "exact_match": false
    }
  },
  {
    "quid": 2000018,
    "question": "In which month did Xi Jinping praise the Bahamas?",
    "ground_truth": [
      "2015-01"
    ],
    "analysis": {
      "question_type": "time_query",
      "time_constraints": "时间范围为2005-01-01到2015-12-31，问题未指定具体年份，需在全部可用年份中搜索",
      "key_entities": [
        "Xi_Jinping",
        "Bahamas"
      ],
      "target_relations": [
        "Praise_or_endorse"
      ],
      "answer_type": "time",
      "query_strategy": "1. 首先在知识图谱中查找所有包含头实体'Xi_Jinping'和尾实体'Bahamas'的三元组\n2. 筛选关系为'Praise_or_endorse'的三元组\n3. 从符合条件的三元组中提取时间属性\n4. 如果没有明确的时间点，则根据时间范围推断可能的月份\n5. 返回具体的月份信息"
    },
    "generated_code": "def query_kg(df):\n    import pandas as pd\n    from datetime import datetime\n    try:\n        # 基础时间过滤\n        df = df[(df['timestamp'] >= '2005-01-01') & (df['timestamp'] <= '2015-12-31')]\n        # 实体过滤\n        key_entities = ['Xi_Jinping', 'Bahamas']\n        entity_filter = pd.Series([False] * len(df))\n        for entity in key_entities:\n            entity_filter |= (\n                df['head'].str.contains(entity, case=False, na=False) |\n                df['tail'].str.contains(entity, case=False, na=False) |\n                (df['head'] == entity) |\n                (df['tail'] == entity)\n        df_filtered = df[entity_filter]\n        # 关系过滤\n        target_relations = ['Praise_or_endorse']\n        if target_relations:\n            relation_filter = df_filtered['relation'].isin(target_relations)\n            for rel in target_relations:\n                relation_filter |= df_filtered['relation'].str.contains(rel, case=False, na=False)\n            df_filtered = df_filtered[relation_filter]\n        if df_filtered.empty:\n            return []\n        # 根据问题确定返回的时间格式\n        if \"which year\" in \"In which month did Xi Jinping praise the Bahamas?\".lower() or \"what year\" in \"In which month did Xi Jinping praise the Bahamas?\".lower():\n            return [str(df_filtered['year'].iloc[0])]\n        elif \"which month\" in \"In which month did Xi Jinping praise the Bahamas?\".lower():\n            return [f\"{{df_filtered['year'].iloc[0]}}-{{df_filtered['month'].iloc[0]}}\"]\n        else:\n            return [str(df_filtered['year'].iloc[0])]\n    except Exception as e:\n        print(f\"查询执行错误: {{e}}\")\n        return [])",
    "predicted_answers": [],
    "evaluation": {
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "exact_match": false
    }
  }
]