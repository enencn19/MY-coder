[
  {
    "quid": 2045036,
    "question": "Who was rejected by the Kuomintang after June, 2007?",
    "qtype": "before_after",
    "answer_type": "entity",
    "time_level": "month",
    "expected_answers": [
      "Tsai Ing-wen",
      "Wang Ching-feng"
    ],
    "predicted_answers": [
      "Wang Ching-feng",
      "Tsai Ing-wen",
      "Ma Ying Jeou",
      "China"
    ],
    "analysis": {
      "question_type": "before_after",
      "qtype": "before_after",
      "answer_type": "entity",
      "time_level": "month",
      "key_entities": [
        "Kuomintang"
      ],
      "entities": [
        "Kuomintang"
      ],
      "time_constraints": [
        "2007"
      ],
      "time": [
        "2007"
      ],
      "target_relations": [],
      "query_strategy": "使用before_after类型查询策略"
    },
    "query_code": "def query_kg(df):\n    import pandas as pd\n    import re\n    try:\n        # 确保数据类型\n        for col in ['head', 'relation', 'tail', 'timestamp']:\n            if col in df.columns:\n                df[col] = df[col].astype(str)\n        \n        entities = ['Kuomintang']\n        question = \"Who was rejected by the Kuomintang after June, 2007?\"  # 确保question变量在代码中定义\n        results = []\n        \n        # 步骤1: 解析时间约束\n        cutoff_time = None\n        question_lower = question.lower()\n        \n        # 从问题中提取时间\n        if 'june, 2007' in question_lower or 'june 2007' in question_lower:\n            cutoff_time = \"2007-06-30\"\n        elif 'august, 2015' in question_lower or 'august 2015' in question_lower:\n            cutoff_time = \"2015-08-31\"\n        elif 'december 2009' in question_lower:\n            cutoff_time = \"2009-12-11\"\n        elif '2005' in question:\n            cutoff_time = \"2005-12-31\"\n        elif '2006' in question:\n            cutoff_time = \"2006-12-31\"\n        elif '2007' in question:\n            cutoff_time = \"2007-12-31\"\n        \n        # 步骤2: 应用时间过滤\n        if cutoff_time:\n            if 'after' in question_lower:\n                time_filter = df['timestamp'] > cutoff_time\n            elif 'before' in question_lower:\n                time_filter = df['timestamp'] < cutoff_time\n            else:\n                time_filter = pd.Series([True] * len(df))\n        else:\n            time_filter = pd.Series([True] * len(df))\n        \n        # 步骤3: 基于问题内容确定关系类型\n        target_relations = []\n        \n        if 'reject' in question_lower:\n            target_relations = [\n                'Reject_plan,_agreement_to_settle_dispute',\n                'Reject_request_for_change_in_leadership', \n                'Reject_request_for_policy_change',\n                'Reject_judicial_cooperation',\n                'Reject_economic_cooperation',\n                'Reject_material_cooperation',\n                'Reject',\n                'Reject_request_for_change_in_institutions,_regime',\n                'Reject_request_for_economic_aid',\n                'Reject_request_for_rights',\n                'Reject_request_or_demand_for_political_reform',\n                'Reject_military_cooperation',\n                'Reject_proposal_to_meet,_discuss,_or_negotiate'\n            ]\n        elif 'decline' in question_lower:\n            target_relations = [\n                'Decline_comment',\n                'Reject_plan,_agreement_to_settle_dispute',\n                'Reject_request_for_policy_change',\n                'Reject_judicial_cooperation',\n                'Reject_economic_cooperation',\n                'Reject_material_cooperation',\n                'Reject',\n                'Reject_request_for_change_in_institutions,_regime'\n            ]\n        elif 'military force' in question_lower:\n            target_relations = ['Use_conventional_military_force', 'Use_unconventional_violence']\n        elif 'condemn' in question_lower:\n            target_relations = ['Criticize_or_denounce']\n        else:\n            target_relations = ['Make_a_visit', 'Host_a_visit', 'Make_statement']\n        \n        # 步骤4: 实体匹配策略\n        for entity in entities:\n            # 策略1: 查找包含该实体名称的所有实体\n            entity_matches = []\n            \n            # 在head中查找\n            head_mask = df['head'].str.contains(entity, case=False, na=False)\n            if head_mask.any():\n                entity_matches.extend(df[head_mask]['head'].unique())\n            \n            # 在tail中查找  \n            tail_mask = df['tail'].str.contains(entity, case=False, na=False)\n            if tail_mask.any():\n                entity_matches.extend(df[tail_mask]['tail'].unique())\n            \n            entity_matches = list(set(entity_matches))\n            \n            # 策略2: 对每个匹配的实体，查找相关关系\n            for matched_entity in entity_matches[:8]:\n                for relation in target_relations:\n                    # 查找该实体作为tail的记录\n                    mask = (\n                        time_filter &\n                        (df['tail'] == matched_entity) &\n                        (df['relation'] == relation)\n                    )\n                    \n                    if mask.any():\n                        for _, row in df[mask].iterrows():\n                            result = row['head']\n                            if result not in results:\n                                results.append(result)\n                    \n                    # 也查找该实体作为head的记录\n                    mask2 = (\n                        time_filter &\n                        (df['head'] == matched_entity) &\n                        (df['relation'] == relation)\n                    )\n                    \n                    if mask2.any():\n                        for _, row in df[mask2].iterrows():\n                            result = row['tail']\n                            if result not in results:\n                                results.append(result)\n        \n        # 步骤5: 如果还是没有结果，尝试更宽松的匹配\n        if not results:\n            for entity in entities[:1]:\n                relation_keywords = []\n                if 'reject' in question_lower:\n                    relation_keywords = ['Reject', 'reject']\n                elif 'decline' in question_lower:\n                    relation_keywords = ['Decline', 'decline', 'Reject']\n                elif 'military force' in question_lower:\n                    relation_keywords = ['military', 'force']\n                \n                for keyword in relation_keywords:\n                    broad_relation_mask = df['relation'].str.contains(keyword, case=False, na=False)\n                    broad_entity_mask = (\n                        df['head'].str.contains(entity, case=False, na=False) |\n                        df['tail'].str.contains(entity, case=False, na=False)\n                    )\n                    \n                    broad_mask = time_filter & broad_relation_mask & broad_entity_mask\n                    \n                    if broad_mask.any():\n                        sample = df[broad_mask].head(8)\n                        for _, row in sample.iterrows():\n                            if entity.lower() in row['tail'].lower():\n                                result = row['head']\n                            else:\n                                result = row['tail']\n                            \n                            if result not in results:\n                                results.append(result)\n                        break\n        \n        return results[:15]\n        \n    except Exception as e:\n        import traceback\n        print(f\"Debug: 查询执行错误: {str(e)}\")\n        print(traceback.format_exc())\n        return []",
    "exact_match": false,
    "precision": 0.5,
    "recall": 1.0,
    "f1": 0.6666666666666666
  },
  {
    "quid": 2006643,
    "question": "Who declined Iran after August, 2015?",
    "qtype": "before_after",
    "answer_type": "entity",
    "time_level": "month",
    "expected_answers": [
      "Kuwait",
      "Other Authorities / Officials (Somalia)",
      "Congress (United States)"
    ],
    "predicted_answers": [
      "Congress (United States)",
      "Kuwait",
      "Other Authorities / Officials (Somalia)",
      "United States Senate",
      "Barack Obama",
      "Royal Administration (Saudi Arabia)",
      "Benjamin Netanyahu",
      "Sudan"
    ],
    "analysis": {
      "question_type": "before_after",
      "qtype": "before_after",
      "answer_type": "entity",
      "time_level": "month",
      "key_entities": [
        "Iran"
      ],
      "entities": [
        "Iran"
      ],
      "time_constraints": [
        "2015"
      ],
      "time": [
        "2015"
      ],
      "target_relations": [],
      "query_strategy": "使用before_after类型查询策略"
    },
    "query_code": "def query_kg(df):\n    import pandas as pd\n    import re\n    try:\n        # 确保数据类型\n        for col in ['head', 'relation', 'tail', 'timestamp']:\n            if col in df.columns:\n                df[col] = df[col].astype(str)\n        \n        entities = ['Iran']\n        question = \"Who declined Iran after August, 2015?\"  # 确保question变量在代码中定义\n        results = []\n        \n        # 步骤1: 解析时间约束\n        cutoff_time = None\n        question_lower = question.lower()\n        \n        # 从问题中提取时间\n        if 'june, 2007' in question_lower or 'june 2007' in question_lower:\n            cutoff_time = \"2007-06-30\"\n        elif 'august, 2015' in question_lower or 'august 2015' in question_lower:\n            cutoff_time = \"2015-08-31\"\n        elif 'december 2009' in question_lower:\n            cutoff_time = \"2009-12-11\"\n        elif '2005' in question:\n            cutoff_time = \"2005-12-31\"\n        elif '2006' in question:\n            cutoff_time = \"2006-12-31\"\n        elif '2007' in question:\n            cutoff_time = \"2007-12-31\"\n        \n        # 步骤2: 应用时间过滤\n        if cutoff_time:\n            if 'after' in question_lower:\n                time_filter = df['timestamp'] > cutoff_time\n            elif 'before' in question_lower:\n                time_filter = df['timestamp'] < cutoff_time\n            else:\n                time_filter = pd.Series([True] * len(df))\n        else:\n            time_filter = pd.Series([True] * len(df))\n        \n        # 步骤3: 基于问题内容确定关系类型\n        target_relations = []\n        \n        if 'reject' in question_lower:\n            target_relations = [\n                'Reject_plan,_agreement_to_settle_dispute',\n                'Reject_request_for_change_in_leadership', \n                'Reject_request_for_policy_change',\n                'Reject_judicial_cooperation',\n                'Reject_economic_cooperation',\n                'Reject_material_cooperation',\n                'Reject',\n                'Reject_request_for_change_in_institutions,_regime',\n                'Reject_request_for_economic_aid',\n                'Reject_request_for_rights',\n                'Reject_request_or_demand_for_political_reform',\n                'Reject_military_cooperation',\n                'Reject_proposal_to_meet,_discuss,_or_negotiate'\n            ]\n        elif 'decline' in question_lower:\n            target_relations = [\n                'Decline_comment',\n                'Reject_plan,_agreement_to_settle_dispute',\n                'Reject_request_for_policy_change',\n                'Reject_judicial_cooperation',\n                'Reject_economic_cooperation',\n                'Reject_material_cooperation',\n                'Reject',\n                'Reject_request_for_change_in_institutions,_regime'\n            ]\n        elif 'military force' in question_lower:\n            target_relations = ['Use_conventional_military_force', 'Use_unconventional_violence']\n        elif 'condemn' in question_lower:\n            target_relations = ['Criticize_or_denounce']\n        else:\n            target_relations = ['Make_a_visit', 'Host_a_visit', 'Make_statement']\n        \n        # 步骤4: 实体匹配策略\n        for entity in entities:\n            # 策略1: 查找包含该实体名称的所有实体\n            entity_matches = []\n            \n            # 在head中查找\n            head_mask = df['head'].str.contains(entity, case=False, na=False)\n            if head_mask.any():\n                entity_matches.extend(df[head_mask]['head'].unique())\n            \n            # 在tail中查找  \n            tail_mask = df['tail'].str.contains(entity, case=False, na=False)\n            if tail_mask.any():\n                entity_matches.extend(df[tail_mask]['tail'].unique())\n            \n            entity_matches = list(set(entity_matches))\n            \n            # 策略2: 对每个匹配的实体，查找相关关系\n            for matched_entity in entity_matches[:8]:\n                for relation in target_relations:\n                    # 查找该实体作为tail的记录\n                    mask = (\n                        time_filter &\n                        (df['tail'] == matched_entity) &\n                        (df['relation'] == relation)\n                    )\n                    \n                    if mask.any():\n                        for _, row in df[mask].iterrows():\n                            result = row['head']\n                            if result not in results:\n                                results.append(result)\n                    \n                    # 也查找该实体作为head的记录\n                    mask2 = (\n                        time_filter &\n                        (df['head'] == matched_entity) &\n                        (df['relation'] == relation)\n                    )\n                    \n                    if mask2.any():\n                        for _, row in df[mask2].iterrows():\n                            result = row['tail']\n                            if result not in results:\n                                results.append(result)\n        \n        # 步骤5: 如果还是没有结果，尝试更宽松的匹配\n        if not results:\n            for entity in entities[:1]:\n                relation_keywords = []\n                if 'reject' in question_lower:\n                    relation_keywords = ['Reject', 'reject']\n                elif 'decline' in question_lower:\n                    relation_keywords = ['Decline', 'decline', 'Reject']\n                elif 'military force' in question_lower:\n                    relation_keywords = ['military', 'force']\n                \n                for keyword in relation_keywords:\n                    broad_relation_mask = df['relation'].str.contains(keyword, case=False, na=False)\n                    broad_entity_mask = (\n                        df['head'].str.contains(entity, case=False, na=False) |\n                        df['tail'].str.contains(entity, case=False, na=False)\n                    )\n                    \n                    broad_mask = time_filter & broad_relation_mask & broad_entity_mask\n                    \n                    if broad_mask.any():\n                        sample = df[broad_mask].head(8)\n                        for _, row in sample.iterrows():\n                            if entity.lower() in row['tail'].lower():\n                                result = row['head']\n                            else:\n                                result = row['tail']\n                            \n                            if result not in results:\n                                results.append(result)\n                        break\n        \n        return results[:15]\n        \n    except Exception as e:\n        import traceback\n        print(f\"Debug: 查询执行错误: {str(e)}\")\n        print(traceback.format_exc())\n        return []",
    "exact_match": false,
    "precision": 0.375,
    "recall": 1.0,
    "f1": 0.5454545454545454
  },
  {
    "quid": 2027657,
    "question": "Who wanted to cooperate with Japan on 23 August 2006?",
    "qtype": "equal",
    "answer_type": "entity",
    "time_level": "day",
    "expected_answers": [
      "Association of Southeast Asian Nations"
    ],
    "predicted_answers": [
      "Association of Southeast Asian Nations"
    ],
    "analysis": {
      "question_type": "equal",
      "qtype": "equal",
      "answer_type": "entity",
      "time_level": "day",
      "key_entities": [
        "Japan"
      ],
      "entities": [
        "Japan"
      ],
      "time_constraints": [
        "2006-08-23"
      ],
      "time": [
        "2006-08-23"
      ],
      "target_relations": [],
      "query_strategy": "使用equal类型查询策略"
    },
    "query_code": "def query_kg(df):\n    import pandas as pd\n    try:\n        # 确保数据类型\n        for col in ['head', 'relation', 'tail', 'timestamp']:\n            if col in df.columns:\n                df[col] = df[col].astype(str)\n        \n        entities = ['Japan']\n        relations = ['Express_intent_to_cooperate']\n        time_constraints = ['2006-08-23']\n        results = []\n        \n        # Equal查询: 在特定时间点的事件\n        if time_constraints:\n            target_time = time_constraints[0]\n            time_filter = df['timestamp'].str.startswith(target_time[:10])\n        else:\n            time_filter = pd.Series([True] * len(df))\n        \n        # 实体和关系匹配\n        for entity in entities:\n            entity_patterns = [entity, entity.replace(' ', '_'), entity.replace('_', ' ')]\n            \n            for pattern in entity_patterns:\n                for relation in relations:\n                    mask = (\n                        time_filter &\n                        (df['tail'].str.contains(pattern, case=False, na=False)) &\n                        (df['relation'] == relation)\n                    )\n                    \n                    if mask.any():\n                        for _, row in df[mask].iterrows():\n                            result = row['head'].replace('_', ' ')\n                            if result not in results:\n                                results.append(result)\n        \n        return results[:1] if len(results) > 0 else []\n        \n    except Exception as e:\n        return []",
    "exact_match": true,
    "precision": 1.0,
    "recall": 1.0,
    "f1": 1.0
  },
  {
    "quid": 2007873,
    "question": "Before 11 December 2009, who used conventional military force against France?",
    "qtype": "before_after",
    "answer_type": "entity",
    "time_level": "day",
    "expected_answers": [
      "Separatist (France)",
      "Comoros",
      "Royal Air Force",
      "Bolivia",
      "Colombia",
      "Christian (France)",
      "Member of Parliament (France)",
      "Military (Russia)"
    ],
    "predicted_answers": [
      "Police (Cote d'Ivoire)",
      "Military (Russia)"
    ],
    "analysis": {
      "question_type": "before_after",
      "qtype": "before_after",
      "answer_type": "entity",
      "time_level": "day",
      "key_entities": [
        "France"
      ],
      "entities": [
        "France"
      ],
      "time_constraints": [
        "2009-12-11"
      ],
      "time": [
        "2009-12-11"
      ],
      "target_relations": [],
      "query_strategy": "使用before_after类型查询策略"
    },
    "query_code": "def query_kg(df):\n    import pandas as pd\n    import re\n    try:\n        # 确保数据类型\n        for col in ['head', 'relation', 'tail', 'timestamp']:\n            if col in df.columns:\n                df[col] = df[col].astype(str)\n        \n        entities = ['France']\n        question = \"Before 11 December 2009, who used conventional military force against France?\"  # 确保question变量在代码中定义\n        results = []\n        \n        # 步骤1: 解析时间约束\n        cutoff_time = None\n        question_lower = question.lower()\n        \n        # 从问题中提取时间\n        if 'june, 2007' in question_lower or 'june 2007' in question_lower:\n            cutoff_time = \"2007-06-30\"\n        elif 'august, 2015' in question_lower or 'august 2015' in question_lower:\n            cutoff_time = \"2015-08-31\"\n        elif 'december 2009' in question_lower:\n            cutoff_time = \"2009-12-11\"\n        elif '2005' in question:\n            cutoff_time = \"2005-12-31\"\n        elif '2006' in question:\n            cutoff_time = \"2006-12-31\"\n        elif '2007' in question:\n            cutoff_time = \"2007-12-31\"\n        \n        # 步骤2: 应用时间过滤\n        if cutoff_time:\n            if 'after' in question_lower:\n                time_filter = df['timestamp'] > cutoff_time\n            elif 'before' in question_lower:\n                time_filter = df['timestamp'] < cutoff_time\n            else:\n                time_filter = pd.Series([True] * len(df))\n        else:\n            time_filter = pd.Series([True] * len(df))\n        \n        # 步骤3: 基于问题内容确定关系类型\n        target_relations = []\n        \n        if 'reject' in question_lower:\n            target_relations = [\n                'Reject_plan,_agreement_to_settle_dispute',\n                'Reject_request_for_change_in_leadership', \n                'Reject_request_for_policy_change',\n                'Reject_judicial_cooperation',\n                'Reject_economic_cooperation',\n                'Reject_material_cooperation',\n                'Reject',\n                'Reject_request_for_change_in_institutions,_regime',\n                'Reject_request_for_economic_aid',\n                'Reject_request_for_rights',\n                'Reject_request_or_demand_for_political_reform',\n                'Reject_military_cooperation',\n                'Reject_proposal_to_meet,_discuss,_or_negotiate'\n            ]\n        elif 'decline' in question_lower:\n            target_relations = [\n                'Decline_comment',\n                'Reject_plan,_agreement_to_settle_dispute',\n                'Reject_request_for_policy_change',\n                'Reject_judicial_cooperation',\n                'Reject_economic_cooperation',\n                'Reject_material_cooperation',\n                'Reject',\n                'Reject_request_for_change_in_institutions,_regime'\n            ]\n        elif 'military force' in question_lower:\n            target_relations = ['Use_conventional_military_force', 'Use_unconventional_violence']\n        elif 'condemn' in question_lower:\n            target_relations = ['Criticize_or_denounce']\n        else:\n            target_relations = ['Make_a_visit', 'Host_a_visit', 'Make_statement']\n        \n        # 步骤4: 实体匹配策略\n        for entity in entities:\n            # 策略1: 查找包含该实体名称的所有实体\n            entity_matches = []\n            \n            # 在head中查找\n            head_mask = df['head'].str.contains(entity, case=False, na=False)\n            if head_mask.any():\n                entity_matches.extend(df[head_mask]['head'].unique())\n            \n            # 在tail中查找  \n            tail_mask = df['tail'].str.contains(entity, case=False, na=False)\n            if tail_mask.any():\n                entity_matches.extend(df[tail_mask]['tail'].unique())\n            \n            entity_matches = list(set(entity_matches))\n            \n            # 策略2: 对每个匹配的实体，查找相关关系\n            for matched_entity in entity_matches[:8]:\n                for relation in target_relations:\n                    # 查找该实体作为tail的记录\n                    mask = (\n                        time_filter &\n                        (df['tail'] == matched_entity) &\n                        (df['relation'] == relation)\n                    )\n                    \n                    if mask.any():\n                        for _, row in df[mask].iterrows():\n                            result = row['head']\n                            if result not in results:\n                                results.append(result)\n                    \n                    # 也查找该实体作为head的记录\n                    mask2 = (\n                        time_filter &\n                        (df['head'] == matched_entity) &\n                        (df['relation'] == relation)\n                    )\n                    \n                    if mask2.any():\n                        for _, row in df[mask2].iterrows():\n                            result = row['tail']\n                            if result not in results:\n                                results.append(result)\n        \n        # 步骤5: 如果还是没有结果，尝试更宽松的匹配\n        if not results:\n            for entity in entities[:1]:\n                relation_keywords = []\n                if 'reject' in question_lower:\n                    relation_keywords = ['Reject', 'reject']\n                elif 'decline' in question_lower:\n                    relation_keywords = ['Decline', 'decline', 'Reject']\n                elif 'military force' in question_lower:\n                    relation_keywords = ['military', 'force']\n                \n                for keyword in relation_keywords:\n                    broad_relation_mask = df['relation'].str.contains(keyword, case=False, na=False)\n                    broad_entity_mask = (\n                        df['head'].str.contains(entity, case=False, na=False) |\n                        df['tail'].str.contains(entity, case=False, na=False)\n                    )\n                    \n                    broad_mask = time_filter & broad_relation_mask & broad_entity_mask\n                    \n                    if broad_mask.any():\n                        sample = df[broad_mask].head(8)\n                        for _, row in sample.iterrows():\n                            if entity.lower() in row['tail'].lower():\n                                result = row['head']\n                            else:\n                                result = row['tail']\n                            \n                            if result not in results:\n                                results.append(result)\n                        break\n        \n        return results[:15]\n        \n    except Exception as e:\n        import traceback\n        print(f\"Debug: 查询执行错误: {str(e)}\")\n        print(traceback.format_exc())\n        return []",
    "exact_match": false,
    "precision": 0.5,
    "recall": 0.125,
    "f1": 0.2
  },
  {
    "quid": 2044815,
    "question": "Which country was the first to ask for France after the Algerian extremist?",
    "qtype": "after_first",
    "answer_type": "entity",
    "time_level": "day",
    "expected_answers": [
      "Iran"
    ],
    "predicted_answers": [
      "France"
    ],
    "analysis": {
      "question_type": "after_first",
      "qtype": "after_first",
      "answer_type": "entity",
      "time_level": "day",
      "key_entities": [
        "France",
        "Anguel Marin"
      ],
      "entities": [
        "France",
        "Anguel Marin"
      ],
      "time_constraints": [],
      "time": [],
      "target_relations": [],
      "query_strategy": "使用after_first类型查询策略"
    },
    "query_code": "def query_kg(df):\n    import pandas as pd\n    try:\n        # 确保数据类型\n        for col in ['head', 'relation', 'tail', 'timestamp']:\n            if col in df.columns:\n                df[col] = df[col].astype(str)\n        \n        results = []\n        print(\"Debug: 开始after_first查询\")\n        \n        # 步骤1: 查找阿尔及利亚相关事件的时间\n        algeria_patterns = ['Algeria', 'Algerian', 'extremist', 'Extremist']\n        reference_time = None\n        \n        # 查找包含阿尔及利亚的实体\n        algeria_entities = []\n        for pattern in algeria_patterns:\n            # 查找实体名称中包含该模式的\n            entity_mask = (\n                df['head'].str.contains(pattern, case=False, na=False) |\n                df['tail'].str.contains(pattern, case=False, na=False)\n            )\n            \n            if entity_mask.any():\n                found_entities = list(df[entity_mask]['head'].unique()) + list(df[entity_mask]['tail'].unique())\n                algeria_entities.extend([e for e in found_entities if pattern.lower() in e.lower()])\n        \n        algeria_entities = list(set(algeria_entities))\n        print(f\"Debug: 找到阿尔及利亚相关实体: {algeria_entities[:3]}\")\n        \n        # 查找这些实体相关的事件时间\n        if algeria_entities:\n            algeria_mask = (\n                df['head'].isin(algeria_entities) |\n                df['tail'].isin(algeria_entities)\n            )\n            \n            if algeria_mask.any():\n                algeria_events = df[algeria_mask]\n                reference_time = algeria_events['timestamp'].min()\n                print(f\"Debug: 参考时间设为{reference_time}\")\n        \n        if not reference_time:\n            reference_time = \"2005-01-01\"\n            print(f\"Debug: 使用默认参考时间{reference_time}\")\n        \n        # 步骤2: 查找在参考时间之后，向France提出请求的记录\n        # 查找包含France的实体\n        france_entities = []\n        france_mask = (\n            df['head'].str.contains('France', case=False, na=False) |\n            df['tail'].str.contains('France', case=False, na=False)\n        )\n        \n        if france_mask.any():\n            found_entities = list(df[france_mask]['head'].unique()) + list(df[france_mask]['tail'].unique())\n            france_entities = [e for e in found_entities if 'france' in e.lower()]\n        \n        france_entities = list(set(france_entities))\n        print(f\"Debug: 找到法国相关实体: {france_entities[:3]}\")\n        \n        # 查找ask/request相关的关系\n        ask_relations = [\n            'Make_an_appeal_or_request',\n            'Appeal_for_economic_cooperation',\n            'Appeal_for_policy_change', \n            'Appeal_for_material_cooperation',\n            'Appeal_for_judicial_cooperation',\n            'Appeal_for_military_cooperation',\n            'Appeal_for_diplomatic_cooperation_(such_as_policy_support)',\n            'Appeal_for_economic_aid',\n            'Appeal_for_humanitarian_aid',\n            'Appeal_for_military_aid'\n        ]\n        \n        # 组合查询\n        for france_entity in france_entities[:3]:\n            for relation in ask_relations:\n                after_mask = (\n                    (df['timestamp'] > reference_time) &\n                    (df['relation'] == relation) &\n                    (df['tail'] == france_entity)\n                )\n                \n                if after_mask.any():\n                    print(f\"Debug: 找到向{france_entity}的{relation}记录\")\n                    after_events = df[after_mask].sort_values('timestamp')\n                    first_event = after_events.iloc[0]\n                    result = first_event['head']\n                    \n                    # 清理结果\n                    if '(' in result and ')' in result:\n                        clean_result = result.split('(')[0].strip('_')\n                        if clean_result:\n                            result = clean_result\n                    \n                    result = result.replace('_', ' ')\n                    results.append(result)\n                    print(f\"Debug: 找到第一个结果: {result}\")\n                    break\n            \n            if results:\n                break\n        \n        # 如果没有找到，尝试更宽松的条件\n        if not results:\n            print(\"Debug: 尝试宽松条件\")\n            broad_mask = (\n                (df['timestamp'] > reference_time) &\n                (df['relation'].str.contains('Appeal', case=False, na=False)) &\n                (df['tail'].str.contains('France', case=False, na=False))\n            )\n            \n            if broad_mask.any():\n                broad_events = df[broad_mask].sort_values('timestamp')\n                first_event = broad_events.iloc[0]\n                result = first_event['head']\n                \n                # 清理结果\n                if '(' in result and ')' in result:\n                    clean_result = result.split('(')[0].strip('_')\n                    if clean_result:\n                        result = clean_result\n                \n                result = result.replace('_', ' ')\n                results.append(result)\n                print(f\"Debug: 宽松条件结果: {result}\")\n        \n        print(f\"Debug: 最终结果{results}\")\n        return results[:1]\n        \n    except Exception as e:\n        import traceback\n        print(f\"Debug: 查询执行错误: {str(e)}\")\n        print(traceback.format_exc())\n        return []",
    "exact_match": false,
    "precision": 0.0,
    "recall": 0.0,
    "f1": 0.0
  },
  {
    "quid": 2016117,
    "question": "Before the Brazilian Ministry of Agriculture, Fishing and Forestry, which country was the last to condemn France?",
    "qtype": "before_last",
    "answer_type": "entity",
    "time_level": "day",
    "expected_answers": [
      "Mexico"
    ],
    "predicted_answers": [],
    "analysis": {
      "question_type": "before_last",
      "qtype": "before_last",
      "answer_type": "entity",
      "time_level": "day",
      "key_entities": [
        "Swaziland",
        "Agriculture / Fishing / Forestry Ministry (Laos)",
        "France"
      ],
      "entities": [
        "Swaziland",
        "Agriculture / Fishing / Forestry Ministry (Laos)",
        "France"
      ],
      "time_constraints": [],
      "time": [],
      "target_relations": [],
      "query_strategy": "使用before_last类型查询策略"
    },
    "query_code": "def query_kg(df):\n    import pandas as pd\n    try:\n        # 确保数据类型\n        for col in ['head', 'relation', 'tail', 'timestamp']:\n            if col in df.columns:\n                df[col] = df[col].astype(str)\n        \n        results = []\n        print(\"Debug: 开始before_last查询\")\n        \n        # 步骤1: 查找Brazilian Ministry相关事件的时间点\n        brazil_patterns = ['Brazil', 'Brazilian', 'Ministry']\n        reference_time = None\n        \n        # 查找包含Brazil/Ministry的实体\n        brazil_entities = []\n        for pattern in brazil_patterns:\n            entity_mask = (\n                df['head'].str.contains(pattern, case=False, na=False) |\n                df['tail'].str.contains(pattern, case=False, na=False)\n            )\n            \n            if entity_mask.any():\n                found_entities = list(df[entity_mask]['head'].unique()) + list(df[entity_mask]['tail'].unique())\n                # 查找同时包含Brazil和Ministry的实体\n                for entity in found_entities:\n                    if 'brazil' in entity.lower() and 'ministry' in entity.lower():\n                        brazil_entities.append(entity)\n        \n        brazil_entities = list(set(brazil_entities))\n        print(f\"Debug: 找到Brazilian Ministry相关实体: {brazil_entities[:3]}\")\n        \n        # 查找这些实体相关的事件时间\n        if brazil_entities:\n            brazil_mask = (\n                df['head'].isin(brazil_entities) |\n                df['tail'].isin(brazil_entities)\n            )\n            \n            if brazil_mask.any():\n                brazil_events = df[brazil_mask]\n                reference_time = brazil_events['timestamp'].min()\n                print(f\"Debug: 参考时间设为{reference_time}\")\n        \n        if not reference_time:\n            # 如果找不到，使用默认时间\n            reference_time = \"2010-01-01\"\n            print(f\"Debug: 使用默认参考时间{reference_time}\")\n        \n        # 步骤2: 查找在参考时间之前，谴责France的记录\n        # 查找包含France的实体\n        france_entities = []\n        france_mask = (\n            df['head'].str.contains('France', case=False, na=False) |\n            df['tail'].str.contains('France', case=False, na=False)\n        )\n        \n        if france_mask.any():\n            found_entities = list(df[france_mask]['head'].unique()) + list(df[france_mask]['tail'].unique())\n            france_entities = [e for e in found_entities if 'france' in e.lower()]\n        \n        france_entities = list(set(france_entities))\n        print(f\"Debug: 找到France相关实体: {france_entities[:3]}\")\n        \n        # 查找condemn相关的关系\n        condemn_relations = [\n            'Criticize_or_denounce',\n            'Disapprove',\n            'Accuse'\n        ]\n        \n        # 组合查询 - 查找在参考时间之前的谴责记录\n        all_condemn_records = []\n        \n        for france_entity in france_entities[:3]:\n            for relation in condemn_relations:\n                before_mask = (\n                    (df['timestamp'] < reference_time) &\n                    (df['relation'] == relation) &\n                    (df['tail'] == france_entity)\n                )\n                \n                if before_mask.any():\n                    print(f\"Debug: 找到对{france_entity}的{relation}记录\")\n                    before_events = df[before_mask]\n                    all_condemn_records.extend(before_events.to_dict('records'))\n        \n        # 如果找到记录，按时间排序，取最后一个\n        if all_condemn_records:\n            sorted_records = sorted(all_condemn_records, key=lambda x: x['timestamp'])\n            last_record = sorted_records[-1]  # 最后一个（最晚的）\n            \n            result = last_record['head']\n            results.append(result)\n            print(f\"Debug: 找到最后一个谴责者: {result}\")\n        \n        # 如果没有找到，尝试更宽松的条件\n        if not results:\n            print(\"Debug: 尝试宽松条件\")\n            broad_mask = (\n                (df['timestamp'] < reference_time) &\n                (df['relation'].str.contains('Criticize', case=False, na=False)) &\n                (df['tail'].str.contains('France', case=False, na=False))\n            )\n            \n            if broad_mask.any():\n                broad_events = df[broad_mask].sort_values('timestamp')\n                last_event = broad_events.iloc[-1]  # 最后一个\n                result = last_event['head']\n                \n                # 清理结果\n                if '(' in result and ')' in result:\n                    clean_result = result.split('(')[0].strip('_')\n                    if clean_result:\n                        result = clean_result\n                \n                result = result.replace('_', ' ')\n                results.append(result)\n                print(f\"Debug: 宽松条件结果: {result}\")\n        \n        print(f\"Debug: 最终结果{results}\")\n        return results[:1]\n        \n    except Exception as e:\n        import traceback\n        print(f\"Debug: 查询执行错误: {str(e)}\")\n        print(traceback.format_exc())\n        return []",
    "exact_match": false,
    "precision": 0.0,
    "recall": 0.0,
    "f1": 0.0
  },
  {
    "quid": 2018890,
    "question": "Who received Juan Carlos I's visit from Juan Carlos I on the same month of Qatar?",
    "qtype": "equal_multi",
    "answer_type": "entity",
    "time_level": "month",
    "expected_answers": [
      "Royal Administration (Spain)",
      "Royal Administration (Jordan)",
      "Royal Administration (Saudi Arabia)"
    ],
    "predicted_answers": [],
    "analysis": {
      "question_type": "equal_multi",
      "qtype": "equal_multi",
      "answer_type": "entity",
      "time_level": "month",
      "key_entities": [
        "Juan Carlos I",
        "Qatar"
      ],
      "entities": [
        "Juan Carlos I",
        "Qatar"
      ],
      "time_constraints": [],
      "time": [],
      "target_relations": [],
      "query_strategy": "使用equal_multi类型查询策略"
    },
    "query_code": "def query_kg(df):\n    import pandas as pd\n    try:\n        # 确保数据类型\n        for col in ['head', 'relation', 'tail', 'timestamp']:\n            if col in df.columns:\n                df[col] = df[col].astype(str)\n        \n        results = []\n        print(\"Debug: 开始equal_multi查询\")\n        \n        # 步骤1: 查找Juan Carlos I访问Qatar的时间\n        # 查找包含Juan Carlos的实体\n        juan_carlos_entities = []\n        juan_carlos_mask = (\n            df['head'].str.contains('Juan Carlos', case=False, na=False) |\n            df['tail'].str.contains('Juan Carlos', case=False, na=False)\n        )\n        \n        if juan_carlos_mask.any():\n            found_entities = list(df[juan_carlos_mask]['head'].unique()) + list(df[juan_carlos_mask]['tail'].unique())\n            juan_carlos_entities = [e for e in found_entities if 'juan carlos' in e.lower()]\n        \n        juan_carlos_entities = list(set(juan_carlos_entities))\n        print(f\"Debug: 找到Juan Carlos相关实体: {juan_carlos_entities[:3]}\")\n        \n        # 查找包含Qatar的实体\n        qatar_entities = []\n        qatar_mask = (\n            df['head'].str.contains('Qatar', case=False, na=False) |\n            df['tail'].str.contains('Qatar', case=False, na=False)\n        )\n        \n        if qatar_mask.any():\n            found_entities = list(df[qatar_mask]['head'].unique()) + list(df[qatar_mask]['tail'].unique())\n            qatar_entities = [e for e in found_entities if 'qatar' in e.lower()]\n        \n        qatar_entities = list(set(qatar_entities))\n        print(f\"Debug: 找到Qatar相关实体: {qatar_entities[:3]}\")\n        \n        # 查找Juan Carlos访问Qatar的记录\n        visit_relations = ['Make_a_visit', 'Host_a_visit']\n        qatar_visit_time = None\n        \n        for juan_entity in juan_carlos_entities:\n            for qatar_entity in qatar_entities:\n                for relation in visit_relations:\n                    # Juan Carlos访问Qatar\n                    visit_mask = (\n                        (df['head'] == juan_entity) &\n                        (df['tail'] == qatar_entity) &\n                        (df['relation'] == relation)\n                    )\n                    \n                    if visit_mask.any():\n                        visit_record = df[visit_mask].iloc[0]\n                        qatar_visit_time = visit_record['timestamp']\n                        print(f\"Debug: 找到访问Qatar的时间: {qatar_visit_time}\")\n                        break\n                    \n                    # Qatar接待Juan Carlos\n                    host_mask = (\n                        (df['head'] == qatar_entity) &\n                        (df['tail'] == juan_entity) &\n                        (df['relation'] == relation)\n                    )\n                    \n                    if host_mask.any():\n                        host_record = df[host_mask].iloc[0]\n                        qatar_visit_time = host_record['timestamp']\n                        print(f\"Debug: 找到接待Juan Carlos的时间: {qatar_visit_time}\")\n                        break\n                \n                if qatar_visit_time:\n                    break\n            if qatar_visit_time:\n                break\n        \n        if not qatar_visit_time:\n            print(\"Debug: 未找到Juan Carlos访问Qatar的记录\")\n            return []\n        \n        # 步骤2: 获取同月时间范围\n        qatar_month = qatar_visit_time[:7]  # YYYY-MM\n        print(f\"Debug: 查找同月 {qatar_month} 的其他访问\")\n        \n        # 步骤3: 查找同月Juan Carlos的其他访问\n        for juan_entity in juan_carlos_entities:\n            for relation in visit_relations:\n                same_month_mask = (\n                    (df['head'] == juan_entity) &\n                    (df['relation'] == relation) &\n                    (df['timestamp'].str.startswith(qatar_month)) &\n                    (~df['tail'].isin(qatar_entities))  # 排除Qatar\n                )\n                \n                if same_month_mask.any():\n                    same_month_visits = df[same_month_mask]\n                    print(f\"Debug: 找到{len(same_month_visits)}个同月访问记录\")\n                    \n                    for _, row in same_month_visits.iterrows():\n                        result = row['tail']\n                        if result not in results:\n                            results.append(result)\n                            print(f\"Debug: 添加结果: {result}\")\n        \n        print(f\"Debug: 最终结果{results}\")\n        return results[:10]\n        \n    except Exception as e:\n        import traceback\n        print(f\"Debug: 查询执行错误: {str(e)}\")\n        print(traceback.format_exc())\n        return []",
    "exact_match": false,
    "precision": 0.0,
    "recall": 0.0,
    "f1": 0.0
  }
]